# 2026-02-14 开发日志

## Checkpoint Lamp 功能完整实现

### 功能概述
实现了完整的 checkpoint 存档点系统，包括：
- checkpoint lamp 激活检测
- 玩家重生逻辑
- killzone 死亡检测与重生
- 视觉反馈和动画系统

---

## 实现要点

### 1. Checkpoint Lamp 核心功能

#### 场景配置 (checkpoint.tscn)
```tscn
[node name="CheckpointLamp" type="Node2D"]
groups = [&"checkpoint"]  # 关键：必须添加到组中
```

**要点**：
- **必须将 CheckpointLamp 节点添加到 `"checkpoint"` 组**
- killzone 通过 `get_tree().get_nodes_in_group("checkpoint")` 查找
- Area2D 的 collision_mask = 4，用于检测玩家

#### 脚本实现 (checkpoint_lamp.gd)

**未激活状态**：
```gdscript
func _ready() -> void:
    # 灰色半透明，不播放动画
    animated_sprite.modulate = Color(0.5, 0.5, 0.5, 0.6)
```

**激活时**：
```gdscript
func _on_area_2d_body_entered(body: Node2D) -> void:
    if body.is_in_group("player") and not active:
        # 播放动画和音效
        animated_sprite.play("default")
        audio_stream_player.play()

        # 恢复颜色并提高亮度
        animated_sprite.modulate = Color(1.3, 1.3, 1.3, 1.0)

        # 记录位置
        lamp_position = global_position
        save_player_pos()

        # 浮动动画
        _play_activation_animation()
```

### 2. Killzone 死亡重生系统

#### 关键实现

**防止重复触发**：
```gdscript
var is_processing: bool = false
var cooldown_timer: Timer

func _on_body_entered(body: Node2D) -> void:
    if not body.is_in_group("player"):
        return

    # 防止重复触发
    if is_processing:
        return

    is_processing = true

    # 查找激活的checkpoint
    var checkpoint = _find_active_checkpoint()

    if checkpoint:
        checkpoint.revive_player(body)
        _start_cooldown()  # 启动冷却
```

**Checkpoint 查找逻辑**：
```gdscript
func _find_active_checkpoint() -> Node:
    var checkpoints = get_tree().get_nodes_in_group("checkpoint")

    for checkpoint in checkpoints:
        if checkpoint.active:  # 直接访问属性
            return checkpoint

    return null
```

**玩家重生**：
```gdscript
func revive_player(player_node: Node2D) -> void:
    if active and player_node:
        # Godot中Y轴向下为正，-20让玩家在上方
        player_node.global_position = Vector2(lamp_position.x + 8, lamp_position.y - 20)

        # 重置速度
        if player_node is CharacterBody2D:
            player_node.velocity = Vector2.ZERO
```

---

## 问题纠正记录

### 问题1：Checkpoint 未激活状态动画不播放

**错误**：在 `_ready()` 中调用了 `animated_sprite.play("default")`

**纠正**：
- 未激活状态应该**不播放动画**，只设置灰色
- 只有玩家触碰时才播放动画

### 问题2：玩家重生后继续掉落

**原因**：Y 轴方向理解错误

**错误代码**：
```gdscript
# ❌ 错误：+20会让玩家在checkpoint更下方
player_node.global_position = Vector2(lamp_position.x + 8, lamp_position.y + 20)
```

**正确代码**：
```gdscript
# ✅ 正确：-20让玩家在checkpoint上方
player_node.global_position = Vector2(lamp_position.x + 8, lamp_position.y - 20)
```

### 问题3：Killzone 无限触发重生

**原因**：玩家重生后仍在 killzone 碰撞体内，导致无限循环

**解决方案**：添加冷却系统
```gdscript
var is_processing: bool = false
var cooldown_timer: Timer

func _start_cooldown() -> void:
    if not cooldown_timer:
        cooldown_timer = Timer.new()
        cooldown_timer.wait_time = 1.0  # 1秒冷却
        cooldown_timer.one_shot = true
        cooldown_timer.timeout.connect(_on_cooldown_finished)
        add_child(cooldown_timer)

    cooldown_timer.start()
```

### 问题4：Checkpoint 场景未添加到组

**现象**：`_find_active_checkpoint()` 找不到任何 checkpoint

**原因**：checkpoint.tscn 中缺少 `groups = [&"checkpoint"]` 配置

**纠正**：在场景文件第41行添加组配置
```tscn
[node name="CheckpointLamp" type="Node2D"]
script = ExtResource("1_o4vow")
groups = [&"checkpoint"]  # 添加这一行
```

### 问题5：Tween API 方法名错误

**错误认知**：认为方法是 `set_looped()`

**正确方法**：Godot 4.x 中是 `set_loops()`（有 s）

**正确用法**：
```gdscript
var float_tween = create_tween()
float_tween.set_loops().set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)

float_tween.tween_property(self, "global_position:y", target_y, duration)
```

**文档**：已创建 `references/Godot_4_Tween_API笔记.md` 记录正确用法

---

## 技术细节

### 颜色亮度调整
- **未激活**：`Color(0.5, 0.5, 0.5, 0.6)` - 50% 亮度，60% 不透明
- **激活后**：`Color(1.3, 1.3, 1.3, 1.0)` - 130% 亮度，让图片更亮

### 浮动动画流程
1. **第一阶段**：向上浮起 16 像素（0.5 秒）
2. **第二阶段**：上下缓慢浮动（1 秒循环）
3. **缓动**：EASE_IN_OUT（渐入渐出）
4. **过渡**：TRANS_SINE（正弦曲线，平滑）

### 坐标系
- Godot 中 **Y 轴向下为正**
- `-20` = 向上 20 像素
- `+20` = 向下 20 像素

---

## 文件清单

### 修改的文件
1. `scripts/items/checkpoint_lamp.gd` - Checkpoint lamp 逻辑
2. `scripts/traps/kill_zone.gd` - Killzone 重生系统
3. `scenes/items/checkpoint.tscn` - 添加组配置

### 新增文件
1. `references/Godot_4_Tween_API笔记.md` - Tween API 参考文档

---

## 总结

今天完整实现了 checkpoint 存档点系统，包括：
- ✅ Checkpoint lamp 激活检测和视觉反馈
- ✅ 玩家重生逻辑（位置重置、速度重置）
- ✅ Killzone 死亡检测与重生
- ✅ 防止重复触发的冷却系统
- ✅ Tween 浮动动画
- ✅ 完整的调试日志

**关键教训**：
1. 组（Group）配置至关重要，killzone 通过组查找 checkpoint
2. Godot Y 轴方向：向下为正，向上用负值
3. 重生系统必须有冷却机制，防止无限触发
4. Tween API 正确方法是 `set_loops()` 而非 `set_looped()`

---

## 钻石（Diamond）收集系统完整实现

### 功能概述
实现了完整的钻石收集系统，包括：
- 钻石道具收集逻辑
- HUD 实时显示
- 存档/读档持久化
- 结果场景统计显示
- 收集动画和音效

---

## 实现要点

### 1. Diamond 收集核心功能

#### 场景配置 (diamond.tscn)
```tscn
[node name="Diamond" type="Node2D"]
script = ExtResource("1_ebm02")

[node name="AnimatedSprite2D" type="AnimatedSprite2D" parent="."]
sprite_frames = SubResource("SpriteFrames_es1yl")
autoplay = "default"

[node name="Area2D" type="Area2D" parent="."]
collision_mask = 4  # 检测玩家（layer 4）

[node name="AudioStreamPlayer" type="AudioStreamPlayer" parent="."]
stream = ExtResource("3_i4kgq")
pitch_scale = 0.9  # 音调降低10%
```

**要点**：
- Area2D 的 `collision_mask = 4` 用于检测玩家（player 在 layer 4）
- AnimatedSprite2D 自动播放 9 帧循环动画
- 音效 pitch_scale = 0.9 使音调略低

#### 脚本实现 (diamond.gd)

**收集流程**：
```gdscript
func _on_area_2d_body_entered(body: Node2D) -> void:
    if body.is_in_group("player"):
        # 1. 隐藏钻石 sprite
        animated_sprite_2d.visible = false

        # 2. 让 area2d 失效（避免重复触发）
        area_2d.collision_layer = 0

        # 3. 在 GlobalData 中增加钻石数量
        GlobalData.player_diamond += 1

        # 4. 记录本轮钻石数量
        GlobalData.add_session_diamond()

        # 5. 保存游戏数据
        SaveLoad.save_game()

        # 6. 播放收集动画效果
        _play_collect_animation()

        # 7. 播放音效，等音效播放完成后再删除节点
        if not audio_finished_connected:
            audio_stream_player.finished.connect(_on_audio_finished)
            audio_finished_connected = true
        audio_stream_player.play()
```

**收集动画**：
```gdscript
func _play_collect_animation() -> void:
    var tween = create_tween()
    tween.set_parallel()

    # 放大效果（1.5倍）
    tween.tween_property(self, "scale", Vector2(1.5, 1.5), 0.2)
    # 渐隐效果（透明度变为0）
    tween.tween_property(animated_sprite_2d, "modulate:a", 0.0, 0.2)
```

**音效完成后删除节点**：
```gdscript
func _on_audio_finished() -> void:
    queue_free()
```

### 2. GlobalData 数据管理

#### 新增变量
```gdscript
var player_diamond: int = 0           # 玩家拥有的钻石总数
var session_diamond_collected: int = 0 # 本局收集的钻石数量
```

#### 新增方法
```gdscript
# 增加本局钻石数量
func add_session_diamond(amount: int = 1) -> void:
    session_diamond_collected += amount

# 获取本局钻石数量
func get_session_diamond_collected() -> int:
    return session_diamond_collected
```

#### 重置方法更新
```gdscript
func reset_session_data() -> void:
    session_coin_collected = 0
    session_fruit_collected = 0
    session_diamond_collected = 0  # 新增
```

**要点**：
- `player_diamond` 是全局总数，用于存档/读档
- `session_diamond_collected` 是本局收集数，用于结果场景显示
- 钻石不在 `save_data()` 方法中保存（通过 `SaveLoad.save_game()` 统一处理）

### 3. SaveSystem 存档系统

#### 保存逻辑
```gdscript
func save_game() -> void:
    # 获取技能树数据
    var skill_data = SkillTreeManager.get_save_data()

    # 数据字典
    var data := {
        "version"      : SAVE_VERSION,
        "coin"         : GlobalData.player_coin,
        "fruit"        : GlobalData.player_fruit,
        "diamond"      : GlobalData.player_diamond,  # 新增
        "skill_states" : skill_data
    }
    file.store_var(data, true)  # true = 压缩
    file.close()
```

#### 读取逻辑
```gdscript
func load_game() -> void:
    var data : Dictionary = file.get_var(true)
    file.close()

    # 版本迁移
    if data.get("version", 0) != SAVE_VERSION:
        data = _migrate(data)

    # 读取钻石数量（默认0）
    GlobalData.player_diamond = data.get("diamond", 0)
```

### 4. HUD 显示更新

#### 脚本更新 (hud.gd)
```gdscript
@onready var diamond_label: Label = $DiamondLabel  # 修正拼写

func _process(_delta: float) -> void:
    var coin:int = GlobalData.player_coin
    coin_label.text = str(coin)

    # 钻石显示逻辑
    var diamond:int = GlobalData.player_diamond
    diamond_label.text = str(diamond)
```

#### 场景配置 (HUD_layer.tscn)
```tscn
[node name="DiamondLabel" type="Label" parent="."]
offset_left = 24.0
offset_top = 32.0
offset_right = 96.0
offset_bottom = 55.0
text = "100"
label_settings = SubResource("LabelSettings_6r1gv")

[node name="AnimatedSpriteDiamond" type="AnimatedSprite2D" parent="."]
position = Vector2(14, 43)
sprite_frames = SubResource("SpriteFrames_bnmgh")
autoplay = "default"
```

**要点**：
- DiamondLabel 位于金币标签下方（top = 32，金币在 top = 16）
- AnimatedSpriteDiamond 作为钻石图标显示

### 5. 结果场景统计

#### 脚本更新 (result_scene.gd)
```gdscript
func _ready():
    # 显示本局收集的钻石数量
    diamond_number.text = str(GlobalData.get_session_diamond_collected())
```

---

## 问题纠正记录

### 问题1：diamond_label 变量名拼写错误

**错误信息**：
```
Identifier "diamond_label" not declared in the current scope
```

**原因**：变量声明时拼写错误
```gdscript
@onready var diamond_lable: Label = $DiamondLabel  # ❌ lable 错误
```

**纠正**：
```gdscript
@onready var diamond_label: Label = $DiamondLabel  # ✅ label 正确
```

### 问题2：钻石数量一次+2

**现象**：玩家触碰钻石后，钻石数量增加2，且音效未播放

**原因**：
1. 音效播放代码缺失：`audio_stream_player.play()` 未调用
2. 信号重复连接导致多次触发

**纠正**：
```gdscript
# 添加播放音效
audio_stream_player.play()

# 使用标志防止重复连接
if not audio_finished_connected:
    audio_stream_player.finished.connect(_on_audio_finished)
    audio_finished_connected = true
```

### 问题3：钻石存档未生效

**现象**：关闭游戏再启动，钻石数量还是0

**原因**：收集钻石时未调用存档方法

**纠正**：在 `_on_area_2d_body_entered()` 中添加
```gdscript
# 保存游戏数据
SaveLoad.save_game()
```

### 问题4：信号回调中设置 collision_layer 报错

**错误信息**：
```
E 0:00:08:333 diamond.gd:17 @ _on_area_2d_body_entered():
Function blocked during in/out signal. <C++ Source> Condition "locked" is true.
```

**原因**：在信号回调中直接修改 Area2D 的碰撞属性被 Godot 4.x 阻止

**解决方案**：直接设置 `collision_layer = 0`
```gdscript
# 方案1：直接设置 collision_layer（推荐）
area_2d.collision_layer = 0

# 方案2：使用 call_deferred（如果需要调用方法）
# call_deferred("_set_monitoring", false)
```

**要点**：
- Godot 4.x 在信号回调中阻止某些 Area2D 属性的修改
- `collision_layer` 可以直接设置（值为0表示无效）
- 不使用 `set_monitoring()` 方法

### 问题5：Area2D 失效的最佳实践

**错误尝试**：
```gdscript
# ❌ 方法不存在
area_2d.set_monitoring(false)

# ❌ 信号回调中被阻止
area_2d.monitoring = false
```

**正确方法**：
```gdscript
# ✅ 最佳实践：设置 collision_layer = 0
area_2d.collision_layer = 0
```

**说明**：
- `collision_layer = 0` 表示该 Area2D 不与任何 layer 碰撞
- 相当于让 Area2D 完全失效
- 不会触发 "Function blocked" 错误

---

## 技术细节

### 钻石收集流程顺序
1. **隐藏 sprite**：`animated_sprite_2d.visible = false`
2. **禁用碰撞**：`area_2d.collision_layer = 0`
3. **更新数据**：`GlobalData.player_diamond += 1`
4. **记录本局**：`GlobalData.add_session_diamond()`
5. **保存存档**：`SaveLoad.save_game()`
6. **播放动画**：放大 + 渐隐（0.2秒并行）
7. **播放音效**：`audio_stream_player.play()`
8. **删除节点**：音效结束后 `queue_free()`

### 动画参数
- **缩放目标**：1.5 倍
- **透明度目标**：0.0（完全透明）
- **持续时间**：0.2 秒
- **并行执行**：`tween.set_parallel()`

### 音效配置
- **音调**：pitch_scale = 0.9（降低10%，更厚重）
- **触发方式**：等待音效播放完成后再删除节点
- **防止重复连接**：使用 `audio_finished_connected` 标志

### 数据流程
```
收集钻石
    ↓
GlobalData.player_diamond += 1  (全局总数)
GlobalData.add_session_diamond()  (本局统计)
    ↓
SaveLoad.save_game()  (立即写入磁盘)
    ↓
下次启动 load_game()  (从存档读取)
```

---

## 文件清单

### 新增文件
1. `scripts/items/diamond.gd` - 钻石收集脚本
2. `scenes/items/diamond.tscn` - 钻石场景

### 修改的文件
1. `scripts/autoload/global_data.gd` - 添加钻石变量和方法
2. `scripts/autoload/save_system.gd` - 添加钻石存档/读档
3. `scripts/ui/hud.gd` - 添加钻石显示
4. `scenes/HUD_layer.tscn` - 添加钻石标签和图标
5. `scripts/ui/result_scene.gd` - 添加钻石统计显示

---

## 总结

钻石收集系统完整实现，包括：
- ✅ 钻石道具收集逻辑（隐藏、禁用、删除）
- ✅ 全局数据和本局统计分离
- ✅ HUD 实时显示（钻石图标 + 数量）
- ✅ 存档/读档持久化
- ✅ 收集动画（放大 + 渐隐）
- ✅ 音效播放和节点清理
- ✅ 结果场景统计显示

**关键教训**：
1. **变量拼写检查**：lable vs label，此类错误难以发现
2. **信号连接防护**：使用标志防止重复连接
3. **信号回调限制**：Godot 4.x 在信号回调中阻止某些属性修改
4. **最佳实践**：使用 `collision_layer = 0` 让 Area2D 失效，而非修改 monitoring
5. **存档时机**：收集后立即存档，避免数据丢失
6. **动画并行**：`set_parallel()` 让多个动画同时执行

---

## 宝箱（Treasure Chest）系统完整实现

### 功能概述
实现了三种稀有度的宝箱系统，包括：
- 普通宝箱（NORMAL）- 生成金币
- 高级宝箱（RARE）- 生成钻石
- 皇家宝箱（ROYAL）- 生成血瓶
- 宝箱开启动画和音效
- 宝物上浮动画

---

## 实现要点

### 1. TreasureItemManager 自动加载单例

#### 枚举定义 (treasure_item_manager.gd)
```gdscript
enum ChestRarity {
    NORMAL,  # 普通宝箱 = 0
    RARE,   # 高级宝箱 = 1
    ROYAL    # 皇家宝箱 = 2
}
```

#### 宝物掉落池配置
```gdscript
var treasure_pools := {
    ChestRarity.NORMAL: [
        {"type": "coin", "scene_path": "res://scenes/items/coin.tscn", "weight": 100}
    ],
    ChestRarity.RARE: [
        {"type": "diamond", "scene_path": "res://scenes/items/diamond.tscn", "weight": 100}
    ],
    ChestRarity.ROYAL: [
        {"type": "health_pot", "scene_path": "res://scenes/items/health_pot.tscn", "weight": 100}
    ]
}
```

**要点**：
- 每种稀有度配置了固定的宝物类型
- 权重系统（weight）支持未来扩展多种掉落
- 提供随机选择方法 `get_random_treasure(rarity)`

### 2. 宝箱脚本实现

#### 类成员变量 (treasure_chest.gd)
```gdscript
enum ChestRarity {
    NORMAL,  # 普通宝箱 = 0
    RARE,   # 高级宝箱 = 1
    ROYAL    # 皇家宝箱 = 2
}

@export var chest_rarity: int = ChestRarity.NORMAL

@onready var animation_player: AnimationPlayer = $AnimationPlayer
@onready var audio_stream_player: AudioStreamPlayer = $AudioStreamPlayer

var is_opened: bool = false
var treasure_node: Node2D = null  # 宝物节点引用
var spawn_pos: Vector2           # 宝物生成位置
```

#### 开启流程
```gdscript
func _on_area_2d_body_entered(body: Node2D) -> void:
    if not body.is_in_group("player"):
        return
    if is_opened:
        return

    is_opened = true

    # 1. 播放开箱动画
    animation_player.play("open_chest")

    # 2. 播放开箱音效
    if audio_stream_player:
        audio_stream_player.play()

    # 3. 生成宝物（使用 call_deferred 避免信号回调冲突）
    call_deferred("_spawn_and_add_treasure")
```

#### 宝物生成（延迟调用）
```gdscript
func _spawn_and_add_treasure() -> void:
    spawn_pos = global_position

    # 根据稀有度获取宝物场景路径
    var treasure_path := ""
    match chest_rarity:
        ChestRarity.NORMAL:
            treasure_path = "res://scenes/items/coin.tscn"
        ChestRarity.RARE:
            treasure_path = "res://scenes/items/diamond.tscn"
        ChestRarity.ROYAL:
            treasure_path = "res://scenes/items/health_pot.tscn"

    # 加载场景并实例化
    var treasure_packed = load(treasure_path)
    treasure_node = treasure_packed.instantiate()

    # 禁用宝箱碰撞体（避免重复触发）
    $Area2D.collision_layer = 0

    # 添加宝物节点到场景
    get_parent().add_child(treasure_node)
    treasure_node.global_position = spawn_pos

    # 添加上浮动画
    _float_treasure(treasure_node)
```

#### 上浮动画
```gdscript
func _float_treasure(treasure: Node2D) -> void:
    var tween = treasure.create_tween()

    # 向上浮动8像素
    var target_y := treasure.global_position.y - 8
    tween.tween_property(treasure, "global_position:y", target_y, 0.3)

    # 添加轻微缓动效果
    tween.set_ease(Tween.EASE_OUT)
    tween.set_trans(Tween.TRANS_SINE)
```

**要点**：
- `@export var chest_rarity` 在检查器中设置，无需修改代码
- 使用 `call_deferred()` 避免信号回调中的状态修改冲突
- `treasure_node` 和 `spawn_pos` 必须是类成员变量，不能是局部变量

### 3. 场景配置

#### 普通宝箱 (chest_normal.tscn)
```tscn
[node name="ChestNormal" type="Node2D"]
script = ExtResource("1_e1h5c")
chest_rarity = 0  # NORMAL

[node name="Sprite2DClose" type="Sprite2D" parent="."]
region_rect = Rect2(8, 32, 16, 16)  # 普通外观

[node name="Sprite2DOpen" type="Sprite2D" parent="."]
region_rect = Rect2(8, 48, 16, 16)
```

#### 高级宝箱 (chest_rare.tscn)
```tscn
[node name="ChestRare" type="Node2D"]
script = ExtResource("1_h5wjn")
chest_rarity = 1  # RARE

[node name="Sprite2DClose" type="Sprite2D" parent="."]
region_rect = Rect2(40, 33, 15, 14)  # 高级外观

[node name="Sprite2DOpen" type="Sprite2D" parent="."]
region_rect = Rect2(40, 48, 15, 15)
```

### 4. 金币收集修复

#### 问题
收集金币后读档，金币数量未正确增加。

#### 原因
`coin.gd` 中收集金币后只更新了内存数据，未调用存档方法。

#### 修复 (coin.gd)
```gdscript
func _on_body_entered(body: Node2D) -> void:
    if body.is_in_group("player"):
        animation_player.play("pick_up")
        GlobalData.add_point()
        GlobalData.add_session_coin()
        SaveLoad.save_game()  # ✅ 添加保存调用
        print("金币 +1，当前: %d" % GlobalData.player_coin)
```

---

## 问题纠正记录

### 问题1：外部枚举引用失败

**错误信息**：
```
Identifier "TreasureItemManager" not declared in the current scope
```

**原因**：尝试通过 `preload()` 从外部脚本引用枚举
```gdscript
# ❌ 错误做法
const ChestRarity = preload("res://scripts/autoload/treasure_item_manager.gd").ChestRarity
```

**解决方案**：在脚本内部重新定义枚举
```gdscript
# ✅ 正确做法
enum ChestRarity {
    NORMAL,
    RARE,
    ROYAL
}
```

### 问题2：信号回调中状态修改冲突

**错误信息**：
```
Can't change this state while flushing queries.
Function blocked during in/out signal. <C++ Source> Condition "locked" is true.
```

**原因**：在 `body_entered` 信号回调中直接添加子节点触发物理查询

**解决方案**：使用 `call_deferred()` 延迟执行
```gdscript
# ❌ 错误做法
func _on_area_2d_body_entered(body: Node2D) -> void:
    get_parent().add_child(treasure_node)  # 直接添加

# ✅ 正确做法
func _on_area_2d_body_entered(body: Node2D) -> void:
    call_deferred("_spawn_and_add_treasure")  # 延迟调用
```

### 问题3：类成员变量声明缺失

**错误信息**：
```
Identifier "treasure_node" not declared in the current scope
```

**原因**：在方法中声明的局部变量无法在其他方法中访问

**解决方案**：在类级别声明成员变量
```gdscript
# ✅ 在类顶部声明
extends Node2D

var treasure_node: Node2D = null  # 类成员变量
var spawn_pos: Vector2           # 类成员变量

func _spawn_and_add_treasure() -> void:
    treasure_node = treasure_packed.instantiate()  # 可以访问

func _float_treasure(treasure: Node2D) -> void:
    # 可以访问 treasure_node 和 spawn_pos
```

### 问题4：金币存档缺失

**错误信息**：
收集金币后读档，金币数量未保存。

**原因**：`coin.gd` 中未调用 `SaveLoad.save_game()`

**解决方案**：添加保存调用
```gdscript
# ✅ 添加保存
func _on_body_entered(body: Node2D) -> void:
    GlobalData.add_point()
    GlobalData.add_session_coin()
    SaveLoad.save_game()  # 立即保存
```

---

## 技术细节

### 宝箱稀有度对照表

| 稀有度 | chest_rarity 值 | 生成道具 | 纹理区域 | 用途 |
|---------|------------------|----------|-----------|------|
| NORMAL | 0 | 金币（coin.tscn） | Rect2(8, 32, 16, 16) | 普通宝箱 |
| RARE | 1 | 钻石（diamond.tscn） | Rect2(40, 33, 15, 14) | 高级宝箱 |
| ROYAL | 2 | 血瓶（health_pot.tscn） | Rect2(?, ?, ?, ?） | 皇家宝箱 |

### 宝箱开启流程顺序
1. **检测玩家**：`body.is_in_group("player")`
2. **防止重复**：`is_opened` 标志检查
3. **播放动画**：`animation_player.play("open_chest")`
4. **播放音效**：`audio_stream_player.play()`
5. **生成宝物**：`call_deferred("_spawn_and_add_treasure")`
6. **禁用碰撞**：`$Area2D.collision_layer = 0`
7. **添加到场景**：`get_parent().add_child(treasure_node)`
8. **设置位置**：`treasure_node.global_position = spawn_pos`
9. **上浮动画**：向上8像素，0.3秒，缓出效果

### call_deferred() 使用场景
- **避免信号回调冲突**：在 `body_entered` 等信号回调中修改场景树
- **避免状态修改阻塞**：Godot 4.x 在物理查询期间阻止某些状态修改
- **延迟执行**：当前帧结束后再执行目标方法

### 宝物上浮动画参数
- **目标位置**：Y 轴 -8 像素（向上）
- **持续时间**：0.3 秒
- **缓动类型**：EASE_OUT（减速）
- **过渡类型**：TRANS_SINE（正弦波）

---

## 文件清单

### 新增文件
1. `scripts/autoload/treasure_item_manager.gd` - 宝物管理器自动加载
2. `scripts/items/treasure_chest.gd` - 宝箱脚本
3. `scenes/items/chest_normal.tscn` - 普通宝箱场景
4. `scenes/items/chest_rare.tscn` - 高级宝箱场景

### 修改的文件
1. `scripts/items/coin.gd` - 添加存档调用

---

## 总结

宝箱系统完整实现，包括：
- ✅ 三种稀有度配置（普通、高级、皇家）
- ✅ 宝箱开启动画和音效
- ✅ 根据稀有度生成不同宝物（金币、钻石、血瓶）
- ✅ 宝物上浮动画（向上8像素）
- ✅ 防止重复触发的保护机制
- ✅ 检查器配置支持（@export 变量）
- ✅ 延迟执行避免信号回调冲突
- ✅ 金币收集存档修复

**关键教训**：
1. **外部枚举引用**：Godot 4.x 不支持通过 preload() 引用外部枚举，需要在脚本内重新定义
2. **信号回调限制**：使用 `call_deferred()` 延迟场景树修改，避免物理查询冲突
3. **类成员变量**：需要在多个方法间共享的变量必须声明为类成员变量
4. **存档完整性**：所有收集类道具都需要调用 `SaveLoad.save_game()` 确保数据持久化
5. **检查器配置**：使用 `@export` 让稀有度等配置可在检查器中直接设置，无需修改代码
6. **纹理区域区分**：不同稀有度使用不同纹理区域（region_rect）提供视觉区分
