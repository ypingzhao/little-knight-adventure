# 🐛 开发问题汇总

> **版本**: 1.1
> **最后更新**: 2025-02-12
> **适用项目**: Little Knight Adventure v0.5
> **目的**: 记录开发中遇到的常见问题和解决方案，避免重复踩坑

---

## 🔗 官方文档参考

**Godot 4.5 官方文档**：
- 📚 [UI 系统教程](https://docs.godotengine.org/en/4.5/tutorials/ui/index.html) - 完整的 UI 开发指南
  - [控件（节点）](https://docs.godotengine.org/en/4.5/tutorials/ui/gui_skinning.html)
  - [主题和样式](https://docs.godotengine.org/en/4.5/tutorials/ui/gui_themes.html)
  - [大小和锚点](https://docs.godotengine.org/en/4.5/tutorials/ui/gui_size_and_anchors.html)
  - [自定义 UI 控件](https://docs.godotengine.org/en/4.5/tutorials/ui/gui_custom_widgets.html)

**资源系统参考**：
- 📚 [资源加载](https://docs.godotengine.org/en/4.5/tutorials/assets/data_paths.html)
- 📚 [UID 系统](https://docs.godotengine.org/en/4.5/tutorials/assets/uid.html)

**GDScript 语言参考**：
- 📘 [GDScript 基础](https://docs.godotengine.org/en/4.5/tutorials/scripting/gdscript/gdscript_basics.html) - 语法、变量、函数、类型
- 📘 [GDScript 进阶](https://docs.godotengine.org/en/4.5/tutorials/scripting/gdscript/gdscript_advanced.html) - 静态类型、数组、字典

**类和 API 参考**：
- 📚 [Godot 4.5 类索引](https://docs.godotengine.org/en/4.5/classes/index.html) - 所有内置类和方法
  - Node2D, CharacterBody2D, CanvasLayer, Area2D, Control 等
  - 完整的属性、方法、信号、常量列表

**这些文档是解决开发问题的权威参考，遇到不确定的问题时建议查阅。**

---

## 🎨 UI 优化最佳实践

根据 [Godot 官方UI文档](https://docs.godotengine.org/en/4.5/tutorials/ui/index.html)，技能树UI 已优化：

### ✅ 优化内容

**1. 统一字体大小**
- 定义字体大小常量：`FONT_SIZE_TITLE = 16`, `FONT_SIZE_BODY = 14`, `FONT_SIZE_VALUE = 12`
- 使用常量而非硬编码，便于统一调整

**2. 增加卡片高度**
- 从 70px 提升到 90px（`CARD_HEIGHT = 90`）
- 提供 20% 更多空间，确保 4 个属性舒适显示

**3. 完善属性显示**
- 每个技能显示 4 个属性：名称、等级、描述、费用、效果值
- 满足"同一屏幕至少显示 3 条属性"的要求

**4. 使用主题颜色常量**
- 定义：`COLOR_NAME`, `COLOR_LEVEL`, `COLOR_DESC`, `COLOR_VALUE`, `COLOR_SUCCESS`, `COLOR_ERROR`
- 统一颜色管理，符合官方最佳实践

**5. 代码组织和注释**
- 添加清晰的代码分隔注释
- 使用语义化的常量名称
- 确保 ScrollContainer 支持垂直滚动
- 所有控件使用 anchors 支持缩放

### 📚 参考文档

- **[Control 类文档](https://docs.godotengine.org/en/4.5/classes/class_control.html)** - size_flags, anchors, 主题
- **[Label 类文档](https://docs.godotengine.org/en/4.5/classes/class_label.html)** - 字体大小、对齐
- **[容器文档](https://docs.godotengine.org/en/4.5/classes/index.html#container-classes)** - VBoxContainer, HBoxContainer, ScrollContainer

### 💡 最佳实践总结

1. ✅ 使用常量定义所有魔法数字（字体大小、颜色、尺寸）
2. ✅ 使用 `add_theme_*_override` API 而非硬编码
3. ✅ 添加清晰的代码注释和分隔
4. ✅ 确保滚动容器正确配置（ScrollContainer）
5. ✅ 所有 4 个属性都正确显示，满足用户需求

---

---

## 📋 目录

1. [CanvasLayer 相关问题](#1-canvaslayer-相关问题)
2. [节点路径问题](#2-节点路径问题)
3. [UI 控件属性问题](#3-ui-控件属性问题)
4. [资源引用问题](#4-资源引用问题)
5. [类型和参数问题](#5-类型和参数问题)
6. [场景实例化问题](#6-场景实例化问题)
7. [最佳实践清单](#7-最佳实践清单)
8. **[存档和技能系统问题](#8-存档和技能系统问题) ⭐ 新增

1. [CanvasLayer 相关问题](#1-canvaslayer-相关问题)
2. [节点路径问题](#2-节点路径问题)
3. [UI 控件属性问题](#3-ui-控件属性问题)
4. [资源引用问题](#4-资源引用问题)
5. [类型和参数问题](#5-类型和参数问题)
6. [场景实例化问题](#6-场景实例化问题)
7. [最佳实践清单](#7-最佳实践清单)

---

## 1. CanvasLayer 相关问题

### ❌ 问题 1.1: 重定义 visible 属性

**错误信息**:
```
Member 'visible' redefined (original in native class 'CanvasLayer')
```

**问题代码**:
```gdscript
# ❌ 错误：CanvasLayer 已经有 visible 属性
extends CanvasLayer

var visible: bool:
    set(value):
        if value:
            show()
        else:
            hide()
```

**解决方案**:
```gdscript
# ✅ 正确：使用自定义属性名
extends CanvasLayer

var is_ui_visible: bool:
    get:
        return _is_visible()
    set(value):
        if value:
            _open_ui()
        else:
            _close_ui()

func _is_visible() -> bool:
    return ui_control != null and ui_control.visible
```

**原因**: CanvasLayer 继承自 Node，已有原生的 `visible` 属性，不能重定义。

**影响文件**:
- `scripts/ui/shop_ui.gd`
- `scripts/ui/skill_tree_ui.gd`

---

### ❌ 问题 1.2: 重写 show()/hide() 方法

**错误信息**:
```
The method 'show()' overrides a method from native class 'CanvasLayer'
```

**问题代码**:
```gdscript
# ❌ 错误：CanvasLayer 已有 show() 和 hide() 方法
extends CanvasLayer

func show() -> void:
    ui_control.visible = true

func hide() -> void:
    ui_control.visible = false
```

**解决方案**:
```gdscript
# ✅ 正确：使用自定义方法名
extends CanvasLayer

func _open_ui() -> void:
    if ui_control:
        ui_control.visible = true
    _disable_player_control()

func _close_ui() -> void:
    if ui_control:
        ui_control.visible = false
    _enable_player_control()
```

**原因**: CanvasLayer 有原生的 `show()` 和 `hide()` 方法，不应重写。

**影响文件**:
- `scripts/ui/shop_ui.gd`
- `scripts/ui/skill_tree_ui.gd`

---

## 2. 节点路径问题

### ❌ 问题 2.1: @onready 路径不匹配

**错误信息**:
```
Node not found: "CloseButton" (relative to "/root/ShopUI")
```

**问题代码**:
```gdscript
# 场景结构调整后未更新路径
@onready var close_button: Button = $ShopUIControl/PanelContainer/VBoxContainer/CloseButton
```

**解决方案**:
```gdscript
# 1. 检查场景文件中的节点路径
# scenes/shop_ui.tscn:
# [node name="CloseButton" type="Button" parent="ShopUIControl/PanelContainer"]

# 2. 更新脚本中的路径
@onready var close_button: Button = $ShopUIControl/PanelContainer/CloseButton
```

**调试方法**:
```gdscript
# 在 _ready() 中打印节点树
func _ready() -> void:
    print_tree_pretty()  # 打印节点树结构
```

**预防措施**:
- 场景结构调整后立即更新脚本路径
- 使用相对路径从脚本所在节点开始
- 在编辑器中拖拽节点到脚本自动生成路径

**影响文件**:
- `scripts/ui/shop_ui.gd`
- `scripts/ui/skill_tree_ui.gd`

---

### ❌ 问题 2.2: 实例化场景节点路径错误

**错误信息**:
```
Node not found: "SkillTreeControl" (relative to "/root/StartGame/SkillTreeUI")
```

**问题原因**:
实例化场景时，节点路径应该从实例的根节点开始。

**解决方案**:
```gdscript
# ❌ 错误：直接使用父场景的路径
@onready var skill_tree_ui = $SkillTreeUI

# ✅ 正确：理解场景实例的节点结构
# start_game.tscn
# StartGame (Node2D)
# └── SkillTreeUI (CanvasLayer, instance)
#     └── SkillTreeControl (Control)
#         └── PanelContainer

# 在 skill_tree_ui.gd 中（脚本附加在 CanvasLayer）
@onready var ui_control: Control = $SkillTreeControl
```

**关键点**:
- 实例化场景的脚本 `self` 是实例的根节点
- 路径从根节点开始查找子节点

---

## 3. UI 控件属性问题

### ❌ 问题 3.1: TextureRect 不支持 alignment 属性

**错误信息**:
```
Invalid assignment 'horizontal_alignment' on TextureRect
```

**问题代码**:
```gdscript
# ❌ 错误：TextureRect 没有 horizontal_alignment 属性
var icon = TextureRect.new()
icon.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
```

**解决方案**:
```gdscript
# ✅ 正确：使用 stretch_mode 控制对齐
var icon = TextureRect.new()
icon.custom_minimum_size = Vector2(50, 50)
icon.expand_mode = TextureRect.EXPAND_FIT_WIDTH_PROPORTIONAL
icon.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED

# 或者使用父容器控制对齐
var container = CenterContainer.new()
container.add_child(icon)
```

**原因**: TextureRect 继承自 Control，但没有 `horizontal_alignment` 属性。

**替代方案**:
- 使用 `CenterContainer` 包裹
- 使用 `stretch_mode` 控制显示方式
- 使用 `TextureButton`（如果需要按钮功能）

**影响文件**:
- `scripts/ui/shop_ui.gd`

---

### ❌ 问题 3.2: 按钮尺寸异常

**错误信息**: ESC 按钮变成占满右侧的长方形

**问题代码**:
```gdscript
# ❌ 错误：offset_bottom 与 offset_top 相同，高度为 0
[node name="CloseButton" type="Button"]
offset_left = -32.0
offset_top = 8.0
offset_right = -8.0
offset_bottom = 8.0  # ❌ 8.0 == 8.0，高度 = 0
```

**解决方案**:
```gdscript
# ✅ 正确：offset_bottom 必须大于 offset_top
[node name="CloseButton" type="Button"]
anchor_left = 1.0
anchor_top = 0.0
anchor_right = 1.0
anchor_bottom = 0.0  # 关键：锚点只锚定顶部，不拉伸高度
offset_left = -32.0
offset_top = 8.0
offset_right = -8.0
offset_bottom = 32.0  # ✅ 32.0 > 8.0，高度 = 24px
custom_minimum_size = Vector2(24, 24)
```

**尺寸计算**:
- 宽度 = `offset_right - offset_left` = -8 - (-32) = 24px
- 高度 = `offset_bottom - offset_top` = 32 - 8 = 24px

**调试方法**:
```gdscript
# 在编辑器中查看节点的 rect_size
print(button.size)  # 输出实际尺寸
```

**影响文件**:
- `scenes/shop_ui.tscn`
- `scenes/ui/skill_tree_ui.tscn`

---

## 4. 资源引用问题

### ❌ 问题 4.1: 图标资源文件不存在

**错误信息**: 资源加载失败，UI 显示空白或崩溃

**问题代码**:
```gdscript
# ❌ 错误：未检查资源是否存在
var icon_texture = load("res://ui/icons/heart.png")
icon.texture = icon_texture  # 如果资源不存在会崩溃
```

**解决方案**:
```gdscript
# ✅ 正确：使用 ResourceLoader.exists() 检查
if item_data.icon_path != "" and ResourceLoader.exists(item_data.icon_path):
    # 加载真实图标
    icon.texture = load(item_data.icon_path)
else:
    # 使用 Emoji 占位符
    placeholder.text = "📦"
    placeholder.visible = true
    icon.visible = false
```

**资源检查函数**:
```gdscript
func load_texture_safely(path: String) -> Texture2D:
    if path.is_empty():
        return null

    if not ResourceLoader.exists(path):
        push_warning("资源不存在: " + path)
        return null

    var texture = load(path)
    if texture == null:
        push_warning("资源加载失败: " + path)
        return null

    return texture
```

**最佳实践**:
- 始终检查资源是否存在
- 提供 fallback 方案（Emoji、默认图标）
- 使用条件渲染显示/隐藏节点

**影响文件**:
- `scripts/ui/shop_ui.gd`
- `scripts/ui/skill_tree_ui.gd`

---

### ❌ 问题 4.2: UID 格式错误

**错误信息**:
```
Parse Error: Expected 4 arguments for constructor.
Failed loading resource: res://scenes/ui/skill_tree_ui.tscn
```

**问题代码**:
```gdscript
# ❌ 错误：自定义的 UID 格式无效
[gd_scene load_steps=3 format=3 uid="uid://skilltreeui001"]
```

**解决方案**:
```gdscript
# ✅ 方法 1：移除 UID，让 Godot 自动生成
[gd_scene load_steps=3 format=3]

# ✅ 方法 2：使用正确的 UID 格式（从 .uid 文件读取）
[gd_scene load_steps=3 format=3 uid="uid://dq5h7x3k8w2p"]
```

**如何获取正确的 UID**:
```bash
# 查找对应的 .uid 文件
cat scripts/ui/skill_tree_ui.gd.uid
# 输出: uid://d2rjpiwjuegof
```

**注意事项**:
- Godot 4 的 UID 格式：`uid://xxxxxxxx`（13位随机字符）
- 不要手动编造 UID
- 新建场景时可以先不写 UID，保存时 Godot 自动生成

**影响文件**:
- `scenes/ui/skill_tree_ui.tscn`

---

### ❌ 问题 4.3: 脚本 UID 引用错误

**错误信息**:
```
Parse Error: Expected 4 arguments for constructor.
```

**问题代码**:
```gdscript
# ❌ 错误：使用了错误脚本的 UID
[ext_resource type="Script" uid="uid://db7kuj6r1ubhg" path="res://scripts/ui/skill_tree_ui.gd" id="1"]
# uid://db7kuj6r1ubhg 是 start_menu.gd 的 UID，不是 skill_tree_ui.gd 的
```

**解决方案**:
```gdscript
# ✅ 正确：使用脚本文件的正确 UID
[ext_resource type="Script" uid="uid://d2rjpiwjuegof" path="res://scripts/ui/skill_tree_ui.gd" id="1"]
```

**如何验证**:
```bash
# 检查脚本对应的 UID 文件
ls -la scripts/ui/skill_tree_ui.gd.uid
cat scripts/ui/skill_tree_ui.gd.uid
```

---

### ❌ 问题 4.4: 手动创建 UID 文件（严重错误！）

**错误信息**:
```
Condition "!int_resources.has(id)" is true. Returning: ERR_INVALID_PARAMETER
Parse Error: Invalid parameter.
Script inherits from native type 'CanvasLayer', so it can't be assigned to an object of type: 'StyleBoxFlat'
```

**问题原因**:
手动创建 `.uid` 文件和场景 UID，导致资源引用混乱。

**❌ 错误做法**:
```bash
# ❌ 永远不要手动创建 .uid 文件！
echo "uid://dq5k7x3n8w2pm" > scenes/ui/skill_tree_ui.tscn.uid

# ❌ 不要手动编写场景 UID
[gd_scene load_steps=3 format=3 uid="uid://dq5k7x3n8w2pm"]
```

**✅ 正确做法**:
```bash
# 1. 删除所有手动创建的 .uid 文件
find . -name "*.uid" -type f -delete

# 2. 移除场景文件中的手动 UID
[gd_scene load_steps=3 format=3]  # 无 UID

# 3. 在 Godot 编辑器中打开并保存场景
# - Godot 自动生成 .uid 文件（针对脚本）
# - Godot 自动生成场景 UID
```

**Godot UID 系统的正确理解**:

1. **`.uid` 文件**：
   - ✅ **只为脚本文件**自动生成（`.gd.uid`）
   - ❌ **场景文件不需要** `.uid` 文件
   - ✅ 由编辑器在保存时自动管理

2. **场景文件中的 UID**：
   - ✅ `[gd_scene ... uid="uid://xxx"]` 由编辑器自动生成
   - ❌ 不要手动编写或修改
   - ✅ 保存场景时自动添加

3. **ExtResource UID**：
   - ✅ `[ext_resource type="Script" uid="uid://xxx" path="..."]`
   - ✅ 由编辑器自动管理
   - ❌ 不要手动修改

**正确的工作流程**:
```
1. 在 Godot 编辑器中创建场景/脚本
2. 按 Ctrl+S 保存
3. Godot 自动生成所有必要的 UID
4. 永远不要手动创建 .uid 文件
```

**为什么会犯错**：
- 误以为 UID 需要手动管理
- 试图"预先"创建 UID 以避免错误
- 不了解 Godot 的自动 UID 系统

**教训**：
- 🔴 **严重级别** - 这是最严重的错误之一
- 🔴 **影响范围** - 导致场景完全无法加载
- 🔴 **修复成本** - 需要删除所有手动 UID，重新保存所有场景

**影响文件**:
- 所有手动创建的 `.uid` 文件（54个文件）
- `scenes/ui/skill_tree_ui.tscn`
- `scenes/start_game.tscn`

**📄 详细复盘文档**: [UID手动创建错误复盘.md](./UID手动创建错误复盘.md) - 包含完整的时间线、根本原因分析和预防措施

**解决方案**:

**解决方案**:
```gdscript
# ✅ 正确：使用脚本文件的正确 UID
[ext_resource type="Script" uid="uid://d2rjpiwjuegof" path="res://scripts/ui/skill_tree_ui.gd" id="1"]
```

**如何验证**:
```bash
# 检查脚本对应的 UID 文件
ls -la scripts/ui/skill_tree_ui.gd.uid
cat scripts/ui/skill_tree_ui.gd.uid
```

---

### ❌ 问题 4.5: 场景文件中使用 GDScript 方法调用

**错误信息**:
```
ERROR: scene/resources/resource_format_text.cpp:113 - Condition "!int_resources.has(id)" is true. Returning: ERR_INVALID_PARAMETER
ERROR: scene/resources/resource_format_text.cpp:279 - Parse Error: Invalid parameter. [Resource file res://scenes/ui/skill_tree_ui.tscn:51]
ERROR: Failed loading resource: res://scenes/ui/skill_tree_ui.tscn.
```

**问题原因**:
在 `.tscn` 场景文件中使用了 GDScript 风格的辅助方法调用，而非场景格式属性。

**❌ 错误代码**（场景文件 .tscn）:
```gdscript
[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_CloseButton"]
bg_color = Color(0.8, 0.2, 0.2, 1.0)
border_color = Color(1.0, 0.3, 0.3, 1.0)
set_border_width_all(2)      # ❌ 这是 GDScript 方法，不能在场景文件中使用！
set_corner_radius_all(4)     # ❌ 这也是 GDScript 方法！
```

**✅ 正确代码**（场景文件 .tscn）:
```gdscript
[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_CloseButton"]
bg_color = Color(0.8, 0.2, 0.2, 1.0)
border_color = Color(1.0, 0.3, 0.3, 1.0)
border_width_left = 2        # ✅ 使用独立属性
border_width_right = 2
border_width_top = 2
border_width_bottom = 2
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4
```

**GDScript vs 场景格式的区别**:

| 场景文件 (.tscn) | GDScript (.gd) |
|------------------|----------------|
| ❌ 不能使用方法调用 | ✅ 可以使用方法调用 |
| ✅ 只能使用属性赋值 | ✅ 可以使用属性和方法 |
| 格式: `property = value` | 格式: `object.method(args)` |

**示例对比**:

场景文件 (.tscn):
```gdscript
[sub_resource type="StyleBoxFlat" id="MyStyle"]
border_width_left = 2
border_width_right = 2
border_width_top = 2
border_width_bottom = 2
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4
```

GDScript 文件 (.gd):
```gdscript
var style = StyleBoxFlat.new()
style.set_border_width_all(2)  # ✅ GDScript 中可以使用
style.set_corner_radius_all(4) # ✅ GDScript 中可以使用
```

**常见错误方法**:
- ❌ `set_border_width_all(value)` → ✅ 使用 4 个独立属性
- ❌ `set_corner_radius_all(value)` → ✅ 使用 4 个独立属性
- ❌ `set_content_margin_all(value)` → ✅ 使用 4 个独立属性

**最佳实践**:
1. 参考现有工作场景文件的格式（如 `shop_ui.tscn`）
2. 不要在 `.tscn` 文件中写任何方法调用
3. 只使用 `property = value` 格式
4. 如需动态样式，在 GDScript 中创建（如 `_setup_hover_effect` 函数）

**为什么会犯错**：
- GDScript 和场景格式看起来相似
- 辅助方法在 GDScript 中更简洁
- 不了解场景文件格式的限制

**教训**：
- 🔴 **严重级别** - 场景完全无法加载
- 🟡 **调试难度** - 错误信息指向 SubResource 行，实际是 sub_resource 定义有问题
- 🟢 **修复成本** - 将方法调用替换为独立属性即可

**影响文件**:
- `scenes/ui/skill_tree_ui.tscn` (已修复)

---

### ❌ 问题 4.6: 信号重复连接

**错误信息**:
```
E 0:00:01:066 skill_tree_ui.gd:66 @ _ready(): Signal 'pressed' is already connected to given callable 'CanvasLayer(skill_tree_ui.gd)::_on_close_button_pressed' in that object.
<C++ 错误> Method/function failed. Returning: ERR_INVALID_PARAMETER
```

**问题原因**:
同一个信号在场景文件和 GDScript 代码中被连接了两次，导致重复连接错误。

**❌ 错误做法**:

场景文件 (`.tscn`) 中已连接：
```gdscript
[connection signal="pressed" from="SkillTreeControl/PanelContainer/CloseButton" to="." method="_on_close_button_pressed"]
```

GDScript (`.gd`) 中又连接：
```gdscript
func _ready() -> void:
    # ❌ 错误：场景文件中已经连接了，这里重复连接
    if close_button:
        close_button.pressed.connect(_on_close_button_pressed)
```

**✅ 正确做法**:

**方案 1：只在场景文件中连接**（推荐）
```gdscript
# 场景文件中的连接保持不变
[connection signal="pressed" from="CloseButton" to="." method="_on_close_button_pressed"]

# GDScript 中删除重复连接
func _ready() -> void:
    # 注意：关闭按钮的 pressed 信号已在场景文件中连接，无需重复连接
    pass
```

**方案 2：只在 GDScript 中连接**
```gdscript
# 场景文件中删除连接（不推荐，容易遗忘）

# GDScript 中连接
func _ready() -> void:
    if close_button:
        close_button.pressed.connect(_on_close_button_pressed)
```

**信号连接的两种方式**:

| 方式 | 适用场景 | 优点 | 缺点 |
|-----|---------|------|------|
| **场景文件连接** | UI 按钮、固定交互 | 可视化，易理解 | 不可见（在 .tscn 中） |
| **代码连接** | 动态创建的节点 | 灵活，可见性强 | 需要手动管理 |

**最佳实践**:
1. **选择一种方式，不要混用**：要么都在场景中连接，要么都在代码中连接
2. **UI 按钮推荐场景连接**：更直观，可视化编辑
3. **动态节点使用代码连接**：无法在场景中预先连接
4. **添加注释说明**：如果场景中已连接，在代码中添加注释提醒

**如何检测重复连接**:
```gdscript
# 检查信号是否已连接
if not close_button.pressed.is_connected(_on_close_button_pressed):
    close_button.pressed.connect(_on_close_button_pressed)
```

**为什么会犯错**：
- 场景文件中的连接不可见（在文本文件底部）
- 习惯性地在 `_ready()` 中连接信号
- 没有检查是否已存在连接

**教训**：
- 🟡 **严重级别** - 运行时错误，但不会导致崩溃
- 🟢 **调试难度** - 错误信息清晰，容易定位
- 🟢 **修复成本** - 删除重复连接即可

**影响文件**:
- `scripts/ui/skill_tree_ui.gd` (已修复)

---

## 5. 类型和参数问题

### ❌ 问题 5.1: 类型转换警告

**错误信息**:
```
Narrowing conversion (float is converted to int and loses precision)
```

**问题代码**:
```gdscript
# ❌ 错误：Input.get_axis() 返回 float，但变量声明为 int
var direction: int
direction = Input.get_axis("left", "right")  # 返回 -1.0 到 1.0
```

**解决方案**:
```gdscript
# ✅ 正确：使用正确的类型声明
var direction: float
direction = Input.get_axis("left", "right")

# 或者显式转换
var direction: int
direction = int(Input.get_axis("left", "right"))
```

**常见返回 float 的函数**:
- `Input.get_axis()`: -1.0 到 1.0
- `randf()`: 0.0 到 1.0
- `lerp()`: 插值结果
- `Vector2.length()`: 浮点数长度

**影响文件**:
- `scripts/actors/player/knight.gd`

---

### ❌ 问题 5.2: Color 构造函数参数缺失

**错误信息**:
```
Parse Error: Expected 4 arguments for constructor.
```

**问题代码**:
```gdscript
# ❌ 错误：Color 只有3个参数（缺少 alpha）
border_color = Color(0.5, 0.5, 0.6)
```

**解决方案**:
```gdscript
# ✅ 正确：Godot 4 的 Color 需要4个参数
border_color = Color(0.5, 0.5, 0.6, 1.0)  # r, g, b, a
```

**Color 构造函数**:
- `Color(r, g, b, a)` - Godot 4 标准格式
- `r`: 红色 (0.0-1.0)
- `g`: 绿色 (0.0-1.0)
- `b`: 蓝色 (0.0-1.0)
- `a`: 透明度 (0.0-1.0)

**常见错误**:
```gdscript
# ❌ Godot 3 风格（Godot 4 不支持）
Color(0.5, 0.5, 0.6)  # 缺少 alpha

# ✅ Godot 4 风格
Color(0.5, 0.5, 0.6, 1.0)  # 完整4参数
Color8(128, 128, 153, 255)  # 使用 0-255 范围
Color.RED  # 使用预设颜色
Color.TRANSPARENT  # 透明
```

**影响文件**:
- `scenes/ui/skill_tree_ui.tscn`

---

## 6. 场景实例化问题

### ❌ 问题 6.1: 场景依赖项缺失

**错误信息**:
```
Failed loading resource: res://scenes/ui/skill_tree_ui.tscn
Missing dependency
```

**问题原因**:
1. UID 格式错误（见问题 4.2）
2. 脚本 UID 引用错误（见问题 4.3）
3. Color 构造函数参数错误（见问题 5.2）

**解决方案**:
```gdscript
# 检查清单：
# 1. 场景文件是否存在
ls -la scenes/ui/skill_tree_ui.tscn

# 2. 检查 UID 格式是否正确
head -1 scenes/ui/skill_tree_ui.tscn
# 应该是: [gd_scene load_steps=X format=3] 或
#         [gd_scene load_steps=X format=3 uid="uid://validformat"]

# 3. 检查脚本引用的 UID
grep "ext_resource type=\"Script\"" scenes/ui/skill_tree_ui.tscn
# UID 应该与 scripts/ui/skill_tree_ui.gd.uid 文件内容一致

# 4. 检查 Color 构造函数
grep "Color(" scenes/ui/skill_tree_ui.tscn
# 所有 Color 都应该有4个参数
```

**调试方法**:
```gdscript
# 在 Godot 编辑器中查看输出面板的错误详情
# 错误会指明具体行号和原因
```

---

## 7. 最佳实践清单

### ✅ CanvasLayer 使用规范

- [ ] 不重定义 `visible` 属性
- [ ] 不重写 `show()` 和 `hide()` 方法
- [ ] 使用自定义属性名（如 `is_ui_visible`）
- [ ] 使用自定义方法名（如 `_open_ui()`, `_close_ui()`）
- [ ] 通过控制子节点的 `visible` 实现 UI 显示/隐藏

### ✅ 节点路径规范

- [ ] 场景结构调整后立即更新脚本路径
- [ ] 使用 `@onready` 延迟获取节点引用
- [ ] 使用 `get_node_or_null()` 安全获取节点
- [ ] 在 `_ready()` 中验证关键节点是否存在
- [ ] 使用 `print_tree_pretty()` 调试节点结构

### ✅ UI 控件使用规范

- [ ] 查阅文档确认控件支持的属性
- [ ] 不给不支持的控件设置属性
- [ ] 使用容器控件控制布局和对齐
- [ ] 检查 `offset_bottom > offset_top` 确保尺寸正确
- [ ] 使用 `custom_minimum_size` 设置最小尺寸

### ✅ 资源管理规范

- [ ] 使用 `ResourceLoader.exists()` 检查资源
- [ ] 提供 fallback 方案（Emoji、默认图标）
- [ ] 不手动编造 UID
- [ ] 检查 `.uid` 文件确认正确的 UID
- [ ] 新场景可以先不写 UID，保存时自动生成

### ✅ 类型安全规范

- [ ] 变量类型与赋值类型匹配
- [ ] 注意函数返回值类型（float vs int）
- [ ] Godot 4 的 `Color` 需要4个参数
- [ ] 使用 `is` 关键字进行类型检查
- [ ] 启用类型警告（项目设置）

### ✅ 调试技巧

- [ ] 使用 `print()` 和 `push_warning()` 输出调试信息
- [ ] 使用 `print_tree_pretty()` 查看节点树
- [ ] 在编辑器输出面板查看详细错误信息
- [ ] 使用断点调试器逐步排查
- [ ] 分批测试，逐步添加功能

### v1.1 (2025-02-12)
- ✅ 添加敌人行为问题总结
- 🔴 严重教训：不要擅自修改没有明确要求修改的代码

---

## 📊 问题统计

### 按类型分类

| 问题类型 | 数量 | 严重程度 |
|---------|------|---------|
| CanvasLayer 冲突 | 2 | 🔴 高 |
| 节点路径错误 | 2 | 🔴 高 |
| UI 控件属性 | 2 | 🟡 中 |
| 资源引用 | 3 | 🔴 高 |
| 类型参数 | 2 | 🟡 中 |
| 场景实例化 | 1 | 🔴 高 |
| **敌人行为** | **4** | 🔴 高 ⭐ 新增 |

### 按影响范围分类

| 影响范围 | 文件数 |
|---------|-------|
| 商店系统 | 3 |
| 技能树系统 | 2 |
| 玩家控制 | 1 |
| **敌人行为** | **1** ⭐ 新增 |

---

## 8. 敌人行为问题

### ❌ 问题 8.1: green slime 无法移动

**错误信息**:
- 敌人初始化后原地不动，没有应用移动逻辑

**问题代码**:
```gdscript
func _physics_process(delta: float) -> void:
    # ... 碰撞检测 ...
    # 缺少移动应用
    # ❌ 没有调用 move_and_slide()
```

**解决方案**:
```gdscript
func _physics_process(delta: float) -> void:
    # ... 碰撞检测和速度设置 ...
    # ✅ 添加移动应用
    move_and_slide()
```

**根本原因**:
- 从其他敌人复制代码时，遗漏了关键的 `move_and_slide()` 调用
- CharacterBody2D 需要显式调用此方法来应用 velocity

**影响文件**:
- `scripts/actors/enemies/slime_green.gd`

**最佳实践**:
- 检查 CharacterBody2D 的 `_physics_process` 必须调用 `move_and_slide()`
- 参考 bat.gd 等工作正常的敌人实现

---

### ❌ 问题 8.2: green slime 朝向和移动方向不一致，死亡瞬间消失

**错误信息**:
- sprite.flip_h 与实际移动方向相反
- 死亡时立即消失，没有播放死亡动画

**问题代码**:
```gdscript
# ❌ 错误1：朝向混乱
if ray_cast_right.is_colliding():
    velocity.x = -abs(velocity.x)  # 第一次设置
    _flip_direction()             # 改变 direction
elif ray_cast_left.is_colliding():
    velocity.x = abs(velocity.x)   # 第一次设置
    _flip_direction()             # 改变 direction

# ❌ 错误2：死亡逻辑混乱
func take_damage(_amount:int)->void:
    # ...
    elif slime_hp <= 0:
        start_invulnerability()  # await 1秒动画
        hit_box.set_deferred("monitorable", false)
    if slime_hp <= 0:
        queue_free()  # 立即删除，不等动画
```

**解决方案（朝向）**:
```gdscript
# ✅ 正确：先确定 direction，再统一设置 velocity
if ray_cast_right.is_colliding():
    _flip_direction()  # 只翻转 direction
elif ray_cast_left.is_colliding():
    _flip_direction()  # 只翻转 direction

# 统一在最后设置速度
velocity.x = direction * SPEED
```

**解决方案（死亡）**:
```gdscript
# ✅ 正确：调用 die() 函数处理异步动画
elif slime_hp <= 0:
    hit_box.set_deferred("monitorable", false)
    die()  # 播放动画 → await → queue_free()

func die() -> void:
    dead = true
    set_physics_process(false)  # 停止物理处理
    hit_box.set_deferred("monitorable", false)
    animated_sprite.play("die")
    await animated_sprite.animation_finished
    queue_free()  # 动画完成后删除
```

**Lesson Learnt**:

1. **变量设置的单一职责原则**
   - velocity.x 在同一帧内被多次设置会产生覆盖
   - 应该先用状态变量（direction）记录意图，最后统一应用到物理变量
   - 口诀："计算 → 赋值状态 → 应用物理"

2. **异步动画与对象生命周期冲突**
   - `await` 动画不会阻塞后续代码，`queue_free()` 立即删除对象
   - 涉及 `await` 的动画必须封装在专门的函数（如 `die()`）
   - 死亡调用专门的 die() 处理异步流程，动画结束后才删除
   - 口诀："异步进，异步出"（await 封装在同一个函数）

3. **状态变量的修改应该集中**
   - 在调用 `_flip_direction()` 前手动修改 `direction *= -1`，而函数内部又修改一次
   - 这导致 direction 被翻转两次（-1 × -1 = 1），等于没有翻转
   - 状态变量的修改应该集中在一个函数中
   - 口诀："要翻转，调函数，别手动改值"

4. **死亡时必须禁用物理处理**
   - 只设置 `dead = true` 不够，`_physics_process` 仍在运行
   - 死亡时应该调用 `set_physics_process(false)` 完全停止物理更新
   - 口诀："死亡停止物理，防止尸体移动"

**影响文件**:
- `scripts/actors/enemies/slime_green.gd`

**最佳实践**:
- 对比 bat.gd 等工作正常的敌人实现
- 参考 boss 的正确闪烁动画实现
- 添加调试日志：`print("die active!")` 和 `print("die animation finished")` 诊断异步问题

---

### ❌ 问题 8.3: green slime 遇到边缘不转向，从边缘掉落

**错误信息**:
- 边缘检测触发后，敌人没有掉头，继续移动掉出平台

**问题代码**:
```gdscript
# ❌ 错误：重复翻转 direction
if not ray_cast_down_a.is_colliding() or not ray_cast_down_b.is_colliding():
    direction *= -1          # 手动翻转（1 → -1）
    _flip_direction()      # 又翻转一次（-1 → 1）= 没变！
```

**解决方案**:
```gdscript
# ✅ 正确：只调用翻转函数
if not ray_cast_down_a.is_colliding() or not ray_cast_down_b.is_colliding():
    _flip_direction()  # 只调用一次，方向正确翻转
```

**根本原因**:
- `_flip_direction()` 内部已经有 `direction *= -1`
- 外部再手动修改一次，导致翻转两次抵消

**Lesson Learnt（补充第4条）**：

4. **状态变量的修改应该集中**（新增）
   - 在调用 `_flip_direction()` 前手动修改 `direction *= -1`
   - 而函数内部又修改一次 `direction *= -1`
   - 这导致 direction 被翻转两次（-1 × -1 = 1），等于没有翻转
   - 口诀："要翻转，调函数，别手动改值"

**影响文件**:
- `scripts/actors/enemies/slime_green.gd`

---

### ❌ 问题 8.4: green slime 死亡动画未播放，原地没有消失

**错误信息**:
- 受击后敌人消失但"尸体"仍在原地
- 控制台没有输出 "die animation finished"

**问题代码**:
```gdscript
func die() -> void:
    dead = true
    print("die active!")
    # ❌ 可能缺少：set_physics_process(false)
    # ❌ 可能缺少：hit_box.set_deferred("monitorable", false)
    animated_sprite.play("die")
    await animated_sprite.animation_finished  # 可能永远不触发
    queue_free()
```

**诊断方法**:
```gdscript
func die() -> void:
    dead = true
    print("die active!")
    set_physics_process(false)  # ✅ 添加：停止物理处理
    hit_box.set_deferred("monitorable", false)  # ✅ 添加：禁用碰撞
    animated_sprite.play("die")
    await animated_sprite.animation_finished
    print("die animation finished, queue_free")  # ✅ 添加：诊断日志
    queue_free()
```

**可能原因**：
1. animated_sprite 节点配置错误（应该是 `$AnimatedSprite2D`）
2. "die" 动画不存在或名称错误（检查精灵表）
3. animation_finished 信号未正确连接
4. 物理处理未停止，velocity 仍更新位置

**根本原因（严重级别）**：
- **没有按照明确的修改请求进行更改**
- 原始代码可能是正常工作的，被"改进"后反而出错
- 多次修改导致问题复杂化，难以定位根本原因

**影响文件**:
- `scripts/actors/enemies/slime_green.gd`

**最佳实践**（最关键）：

🔴 **严重教训：不要擅自修改没有明确要求修改的代码**
- 原始代码可能是正常工作的
- "改进"可能引入新的问题
- 如果不确定是否需要修改，先询问用户

📋 **下次修改原则**：
1. **只修改明确要求的部分** - 不主动"改进"其他逻辑
2. **最小化改动** - 一次只解决一个问题，不要同时修改多个地方
3. **添加前先询问** - 如果需要添加/修改功能，先说明原因并等待确认
4. **提供诊断方案** - 如果问题不确定，先提供检查步骤而不是直接修改

**为什么会犯错**：
- 用户只报告"无法移动"，就主动修改了碰撞检测、死亡逻辑等
- 每次修改都假设"这个可能有问题"，导致正常工作的代码被改坏
- 没有理解原始设计意图，就用"最佳实践"替换

**如何避免**：
- 定位到具体问题点（如"缺少 move_and_slide()"）
- 只修改必要的部分
- 保留其他逻辑不变，即使看起来"不优雅"

---

## 🔗 相关文档

- [商店系统实现文档.md](./商店系统实现文档.md) - 商店系统问题详解
- [技能树UI实现文档.md](./技能树UI实现文档.md) - 技能树 UI 问题详解
- [Lessons_Learnt_复盘清单.md](./Lessons_Learnt_复盘清单.md) - 项目迁移问题汇总
- [敌人行为问题总结.md](./敌人行为问题总结.md) - 敌人移动、受击、死亡逻辑 ⭐ 新增

---

## 📝 更新日志

### v1.1 (2025-02-12)

#### ✅ 完成功能

1. **修复 green slime 移动问题**
   - 添加缺失的 `move_and_slide()` 调用
   - 文件：[slime_green.gd:53](../scripts/actors/enemies/slime_green.gd#L53)
   - 问题：CharacterBody2D 未调用 move_and_slide() 导致 velocity 不生效

2. **修复 green slime 死亡效果**
   - 实现死亡闪烁动画（闪烁 1 秒后消失）
   - 文件：[slime_green.gd:93-106](../scripts/actors/enemies/slime_green.gd#L93-L106)
   - 新增 `die_with_flash()` 函数处理死亡闪烁效果

3. **创建敌人行为问题总结文档**
   - 文件：[敌人行为问题总结.md](./敌人行为问题总结.md)
   - 记录敌人移动、受击、死亡逻辑中的常见问题
   - 总结核心教训和最佳实践

4. **更新开发问题汇总文档**
   - 添加"8. 敌人行为问题"章节
   - 统计问题类型和影响范围

#### 🔴 问题复盘

**问题**：过度修改正常工作的代码，导致引入新问题

**具体表现**：
- 用户报告"green slime 无法移动"
- 我不仅添加了 `move_and_slide()`，还修改了碰撞检测、死亡逻辑、边缘转向等多个地方
- 结果：这些"改进"引入了新问题（朝向错误、边缘不转向、死亡动画不播放）
- 用户不得不多次回退代码，最终只保留 `take_damage` 相关修改

**根本原因**：
1. ❌ 没有遵循"只修改明确要求的部分"原则
2. ❌ 看到代码风格不统一就主动"改进"，而不是询问用户
3. ❌ 多次修改导致问题复杂化，难以定位根本原因
4. ❌ 假设原始代码有问题，但实际上可能是正常工作的

**经验教训**：

1. **最小化改动原则**
   - ✅ 只修复明确报告的问题
   - ✅ 不主动"改进"其他逻辑，即使看起来"不优雅"
   - ✅ 一次只解决一个问题，不要同时修改多个地方

2. **添加前先询问**
   - 如果需要添加/修改功能，先说明原因
   - 等待用户确认后再执行
   - 例如："我发现这里缺少 xxx，是否需要添加？"

3. **提供诊断方案而非直接修改**
   - 如果问题不确定，先提供检查步骤
   - 例如："请检查是否调用了 move_and_slide()"
   - 而不是直接修改代码

4. **状态变量和物理变量的分离**
   - velocity.x 在同一帧内被多次设置会产生覆盖
   - 应该先用状态变量（如 direction）记录意图
   - 最后统一应用到物理变量
   - 口诀："计算 → 赋值状态 → 应用物理"

5. **异步动画与对象生命周期**
   - `await` 动画不会阻塞后续代码执行
   - 涉及 `await` 的动画必须封装在专门的函数中
   - 死亡时调用专门的 `die()` 函数处理异步流程
   - 口诀："异步进，异步出"（await 封装在同一个函数）

**改进措施**：
1. 修改代码前先问自己："这是用户明确要求修改的吗？"
2. 如果不是，就不要改，或者先询问用户
3. 每次修改记录修改内容和原因
4. 保留其他逻辑不变，即使看起来"不优雅"

#### 📊 统计数据

- 修改次数：4+ 次
- 引入问题数：3 个
- 浪费 tokens：大量
- 最终状态：用户回退大部分修改，只保留必要的更改
- 时间损失：约 1 小时（包括回退和重新修复）

---

### v1.0 (2025-02-11)
- 初始版本
- 记录商店系统和技能树系统开发中的问题
- 整理最佳实践清单
- 添加问题统计和分类

---

**创建目的**: 避免在未来的 UI 开发中重复踩坑
**维护建议**: 每次遇到新问题都应更新此文档
**使用方法**: 遇到 UI 问题时先查找此文档，看是否有类似案例
