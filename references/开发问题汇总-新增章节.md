# 新增章节：存档和技能系统问题

> **日期**: 2025-02-13
> **版本**: v1.1
> **说明**: 本次开发中技能存档系统的完整问题复盘和解决方案

---

## ❌ 问题 8.1: 技能升级后重启游戏失效

**错误信息**:
```
技能等级和加成未从存档恢复
```

**错误场景**:
1. 升级一个技能（如"生命值" Lv.1）
2. 关闭游戏
3. 重新启动游戏
4. 技能等级回到0，加成未生效

---

### 根本原因

#### 1. 累加操作错误

`load_save_data()` 中使用 `_apply_skill_effect()` 应用技能效果，该函数内部使用 `+=` 累加值（如 `GlobalData.skill_health += value`），每次加载存档时重复累加，导致数值越来越大。

#### 2. 数据结构嵌套

`get_save_data()` 返回包含额外包装的字典，存档保存为：
```json
{
  "skill_states": {
    "skill_states": { "health": {...}, "attack": {...} }
  }
}
```
导致加载时 `data.skill_states` 是 `null`（NIL 类型）。

#### 3. _ready() 覆盖加载的数据

`load_save_data()` 在 `GlobalData._ready()` 期间被调用，此时 `SkillTreeManager._ready()` 尚未执行。之后 `SkillTreeManager._ready()` 执行，调用 `_initialize_skill_states()`，重置所有技能等级为0，覆盖了刚加载的存档数据。

---

### 修复方案

#### 1. 使用直接设置而非累加

```gdscript
// ❌ 错误：累加
func _apply_skill_effect(skill_id, level):
    GlobalData.skill_health += effect_value

// ✅ 正确：直接设置
func load_save_data(data):
    for skill_id in data.keys():
        var skill_config = SKILL_CONFIG[skill_id]
        var effect_value = skill_config.value_per_level[level - 1]

        match skill_config.effect_type:
            "increase_max_health":
                GlobalData.skill_health = effect_value  // 直接设置
```

#### 2. 添加嵌套结构检测和解包

```gdscript
// 在 get_save_data() 中
func get_save_data() -> Dictionary:
    if skill_states.has("skill_states"):
        return skill_states.skill_states.duplicate(true)  // 解包
    return skill_states.duplicate(true)

// 在 save_game() 中也检测
func save_game():
    if typeof(skill_data) == TYPE_DICTIONARY and skill_data.has("skill_states"):
        skill_data = skill_data.skill_states  // 解包
```

#### 3. 防止 _ready() 重复初始化

```gdscript
var _is_loaded_from_save: bool = false  // 添加标志

func load_save_data(data: Dictionary):
    skill_states = data
    _is_loaded_from_save = true  // 标记已加载

func _ready():
    if not _is_loaded_from_save:  // 检查标志
        _initialize_skill_states()  // 只有未加载时才初始化
```

---

### 教训总结

#### 1. 异步数据加载要注意初始化顺序

`_ready()` 在存档加载后也会执行，会覆盖加载的数据。需要添加标志或延迟初始化来避免覆盖。

#### 2. 使用 duplicate() 深拷贝时要注意数据结构

检查是否有嵌套的包装结构，在保存和加载时都要检测并解包。

#### 3. 状态更新应该直接赋值而非累加

除非明确需要累加，否则使用 `=` 而非 `+=`，避免重复调用时数值异常增长。

#### 4. 提供详细的调试输出

添加 `print()` 在关键步骤输出数据结构和类型，帮助快速定位数据流问题。

---

## 合并说明

**请手动合并**：将此文件内容追加到 `开发问题汇总.md` 文件末尾（或插入到第7节之后）

**步骤**：
1. 打开 `开发问题汇总-新增章节.md`
2. 复制全部内容
3. 打开 `开发问题汇总.md`
4. 将新章节内容粘贴到文件末尾
5. 删除 `开发问题汇总-新增章节.md`
